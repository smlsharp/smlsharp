(**
 * user errors detected in type inference phase.
 * @author OHORI Atsushi
 * @version $Id: TypeInferenceError.ppg,v 1.54 2006/01/17 11:19:25 ohori Exp $
 *)
structure TypeInferenceError =
struct

  (***************************************************************************)

  local
    datatype path = datatype Path.path
    type longid = Absyn.longid
    structure UE = UserError
    val format_idState = Types.format_idState []
    val format_ty = Types.format_ty []
    val format_absynTy = Absyn.format_ty 
    structure PT = PatternCalcWithTvars
    val errorQueue = UE.createQueue ()
  in

  (*%
   * @formatter(Types.idState) format_idState
   * @formatter(Types.ty) format_ty
   * @formatter(Absyn.ty) format_absynTy
   * @formatter(path) Path.format_pathWithoutDotend
   * @formatter(longid) Absyn.format_longid
   * @formatter(PT.ptpat) PT.format_ptpat
   *)
  exception
  (**
   * <pre>
   *  type t = (int, int) option
   * </pre>
   *)
  (*%
   * @format({tyCon, wants, given})
   *   "type" +d "constructor" +d tyCon +d "given" +d given +d "arguments,"
   *  +d "wants" +d wants
   *)
  ArityMismatchInTypeDeclaration of
  {tyCon : string, wants : int, given : int}

  and
  (**
    fn A.c => e 
    where A.c is not a data constructor
   *)
  (*%
   * @format(longid:longid)  
   * "path" +d longid +d "is" +d "not" +d "a" +d "constructor"
   *)
  NonConstructorPathInPat of longid

  and
  (**
    fn A.c => e 
    where A.c is not defined.
   *)
  (*%
   * @format(longid:longid)  
   * "constructor" +d "path" +d longid +d "undefined"
   *)
  ConstructorPathNotFound of longid

  and
  (**
   * <pre>
   * fn x => case x of SOME => 1
   * </pre>
   *)
  (*%
   * @format({dummyTyList:ty tys}) 
    "dummy" +d "type" +d "variable(s)" +d tys(ty)(","+d) +d
    "are" +d "introduced" +d "due" +d "to" +d "value" +d "restriction"
   *)
  ValueRestriction of {dummyTyList : Types.ty list}

  and
  (**
   * <pre>
   * fn x => case x of SOME => 1
   * </pre>
   *)
  (*%
   * @format({con}) "data" +d "constructor" +d {con} +d "used" +d "without"
   *  +d "argument" +d "in" +d "pattern"
   *)
  ConRequireArg of {con : string}

  and
  (**
   * <pre>
   * fn x => case x of NONE 1 => 1
   * </pre>
   *)
  (*%
   * @format({con}) "constant" +d "constructor" +d "applied" +d "to" +d
   *    "argument" +d "in" +d "pattern:" {con}
   *)
  ConstantConApplied of {con : string}

  and
  (**
   * <pre>
   * datatype t = D of 'a
   * val x = y : 'a   (top level)
   * </pre>
   *)
  (*%
   * @format({tyvar}) "free" +d "type" +d "variable:" +d {tyvar}
   *)
  NotBoundTyvar of {tyvar : string}

  and
  (**
   * <pre>
   * datatype t = D of 'a
   * val x = y : 'a   (top level)
   * </pre>
   *)
  (*%
   * @format({tyvar}) "duplicate" +d "type" +d "parameter" +d "name" +d "in" +d "datatype" +d "declaration:" +d {tyvar}
   *)
  DuplicateTvarNameInDatatypeArgs of {tyvar : string}

  and
  (**
   * <pre>
   * datatype ''a t = D of 'a
   * </pre>
   *)
  (*%
   * @format({tyvar}) "Inconsistent" +d "equality" +d "types" +d "in" +d "datatype" +d "declaration:" +d {tyvar}
   *)
  InconsistentEQInDatatype of {tyvar : string}

  and
  (**
   * <pre>
   * fun g x = f true and f x = g (x + 1);
   * </pre>
   *)
  (*%
   * @format({id, definition, occurrence})
   *  "definition" +d "and" +d "occurrence" +d "of" +d "\"" {id} "\"" +d
   * "don't" +d "agree." +1
   * "definition:" +d {definition} +1
   * "occurrence:" +d {occurrence}
   *)
  RecDefinitionAndOccurrenceNotAgree of
  {id : string, definition : Types.ty, occurrence : Types.ty}

  and
  (**
   * <pre>
   *  fn x => case x of {a = x, b = x, c = y, d = y} => 1
   * </pre>
   *)
  (*%
   * @format({vars : var vars})
   *   "duplicate" +d "variables" +d "in" +d "pattern(s):" +d vars(var)("," +d)
   *)
  DuplicatePatternVar of {vars : string list}

  and
  (**
   * <pre>
   *  type ('a, 'a) t = 'a * 'a
   * </pre>
   *)
  (*%
   * @format({tvars : tvar tvars})
   *     "duplicate" +d "type" +d "variables" +d "name:" tvars(tvar)("," +d)
   *)
  DuplicateTargsInTypeDef of {tvars : string list}

  and
  (**
   * <pre>
   *  fn x => case x of 1 1 => 1
   * </pre>
   *)
  (*%
   * @format({pat})
   * "non-constructor" +d "applied" +d "to" +d "argument" +d "in" +d "pattern:"
   * +d {pat}
   *)
  NonConstruct of {pat : PT.ptpat}

  and
  (**
   * <pre>
   *   val x = 1 1
   * </pre>
   *)
  (*%
   * @format({ty}) "operator" +d "is" +d "not" +d "a" +d "function:" +d {ty}
   *)
  NonFunction of {ty : Types.ty}

  and
  (**
   * <pre>
   *   raise 1
   * </pre>
   *)
  (*%
   * @format({ty})
   * "the" +d "argument" +d "of" +d "raise" +d "is" +d "not" +d "a" +d
   * "function." +1
   * "argument:" +d {ty}
   *)
  RaiseArgNonExn of {ty : Types.ty}

  and
  (**
   * <pre>
   *   raise 1
   * </pre>
   *)
  (*%
   * @format({label})
   * "the" +d "non-existing" +d "label" +d "in" +d "field" +d "selector" +d
   * "expression" +1
   * "label:" +d {label}
   *)
  FieldNotInRecord of {label : string}

  and
  (**
   * <pre>
   *   not 1
   * </pre>
   *)
  (*%
   * @format({domTy, argTy})
   * "operator" +d "and" +d "operand" +d "don't" +d "agree"
   *        +1  "operator domain:" + {domTy}
   *        +1  "operand:" + {argTy}
   *)
  TyConMismatch of {domTy: Types.ty, argTy:Types.ty}

  and
  (**
   * <pre>
   *   not 1
   * </pre>
   *)
  (*%
   * @format({domTyList:dty dtys , argTyList: aty atys})
   * "operator" +d "and" +d "operand" +d "don't" +d "agree"
   *        +1  "operator domain:" + {dtys(dty)(","+d)}
   *        +1  "operand:" + {atys(aty)(","+d)}
   *)
  TyConListMismatch of {domTyList: Types.ty list, argTyList:Types.ty list}

  and
  (**
   * <pre>
   *   not 1
   * </pre>
   *)
  (*%
   * @format({funTy, argTy})
   * "operator" +d "and" +d "operand" +d "don't" +d "agree"
   *        +1  "operator:" + {funTy}
   *        +1  "operand:" + {argTy}
   *)
  FunTyConMismatch of {funTy: Types.ty, argTy:Types.ty}

  and
  (**
   * <pre>
   *   not 1
   * </pre>
   *)
  (*%
   * @format({patTy, expTy})
   * "types" +d "of" +d "pattern" +d "and" +d "expression" +d "don't"
   * +d "agree" +d "in" +d "declaration"
   *        +1  "pattern type:" + {patTy}
   *        +1  "expression type:" + {expTy}
   *)
  PatternExpMismatch of {patTy: Types.ty, expTy:Types.ty}

  and
  (**
   * <pre>
   *    1 => 1
   *  | "1" => "1"
   * </pre>
   *)
  (*%
   * @format({thisRule, otherRules}) 
   * "type" +d "of" +d "a" +d "rule" +d "does" +d "not" +d "agree" +d
   * "with" +d "other" +d "rules"
   *        +1  "this rule:" + {thisRule}
   *        +1  "other rules:" + {otherRules}
   *)
  RuleTypeMismatch of {thisRule: Types.ty, otherRules:Types.ty}

  and
  (**
   * <pre>
   *   not 1
   * </pre>
   *)
  (*%
   * @format({expTy, handlerTy}) 
   *  "handler" +d "type" +d "does" +d "not" +d "agree" +d "with" +d
   * "expression"
   *        +1  "expression type:" + {expTy}
   *        +1  "handler type:" + {handlerTy}
   *)
  HandlerTy of {expTy: Types.ty, handlerTy:Types.ty}

  and
  (**
   * <pre>
   *   not 1
   * </pre>
   *)
  (*%
   * @format({ty, annotatedTy})
   *    "type" +d "and" +d "type annotation" +d "don't" +d "agree"
   *        +1  "inferred type:" + {ty}
   *        +1  "type annotation:" + {annotatedTy}
   *)
  TypeAnnotationNotAgree of {ty : Types.ty, annotatedTy : Types.ty}

  and
  (**
   * <pre>
   *  fn x => case x of NONE as y => y
   * </pre>
   *)
  (*%
   * @format({id})
   *  "pattern" +d "to" +d "left" +d "of" +d "\"as\"" +d "must" +d "be"
   *        +d  "variable:"  +d id
   *)
  NonIDInLayered of {id : string}

  and
  (**
   * <pre>
   * exception E = x
   * </pre>
   *)
  (*%
   * @format({tyCon}) "found" +d "data" +d "constructor" +d "instead" +d "of"
   *        +d "exception:" +1 tyCon
   *)
  NotExnCon of {tyCon : string}

  and
  (*% 
    @format
   * "Type" +d "error;" +d "record" +d "lables" +d "do" +d "not" +d "agree."
   *)
  (**
   * <p>
   * </p>
   *)
  RecordLabelSetMismatch

(* this must go to elab.
  and
  (**
   * <p>
   *  val rec (x, y) = (fn x => x, fn x => x)
   * </p>
   *)
  (*%
   * @format "left" +d "hand" +d "of" +d "val" +d "rec" +d "must" +d "be" +d
   *         "be" +d "variable"
   *)
  RecValNotID
*)

  and
  (**
   * <pre>
   *  type t = foo
   * </pre>
   *)
  (*%
   * @format({tyCon}) "unbound" +d "type" +d "constructor:" +d tyCon
   *)
  TyConNotFoundInRawTy of {tyCon : string}

  and
  (**
   * <pre>
   * type foo = ty
   * datatype t = foo
   * </pre>
   *)
  (*%
   * @format({tyCon}) "type" +d "constructor" +d "expected:" +d tyCon
   *)
  TyConNotFoundInReplicateData of {tyCon : string}

  and
  (**
   * <pre>
   * spec 
   * share t1 = t2 (with some ti not defined in spec)
   * </pre>
   *)
  (*%
   * @format({tyCon})
   * "type" +d "constructor" +d "name" +d "not" +d "declared:" +d tyCon
   *)
  TyConNotFoundInShare of {tyCon : string}

  and
  (**
   * <pre>
   * datatype t = datatype foo
   * </pre>
   *)
  (*%
   * @format({tyFun}) "unbound" +d "type" +d "constructor:" +d tyFun
   *)
  TyFunFoundInsteadOfTyCon of {tyFun : string}

  and
  (**
   * <pre>
   * val x = foo 1
   * exception e = foo
   * </pre>
   *)
  (*%
   * @format({id}) "unbound" +d "variable" +d "or" +d "constructor:" +d id
   *)
  VarNotFound of {id : string}

  and
  (**
   * <p>
   *   exception foo of 'a
   * </p>
   *)
  (*%
   * @format(id)
   * "free" +d "type" +d "variable" +d "in" +d "exception" +d "type"
   *)
  FreeTypeVariablesInExceptionType of {exid:string}

  and
  (**
   * <p>
   * sig
   *    val a : int
   *    val a : bool
   * end
   * </p>
   *)
  (*%
   * @format "having" +d "duplicate" +d "specification"
   *)
  DuplicateSpecs

  and
  (**
   * <p>
   * sig
   *    val a : int
   *    val a : bool
   * end
   * </p>
   *)
  (*%
   * @format({id}) "duplicate" +d "specification:" +d id
   *)
  DuplicateSpecification of {id:string}

  and 
  (**
   * <p>
   * structure A : foo =
   * struct
   *      ...
   * end
   * </p>
   *)
  (*%
   * @format({id}) "unbound" +d "signature:" +d id
   *)
  SignatureNotFound of {id:string}

  and
  (**
   * <p>
   * functor A (S: <sigexp>) =
   * struct
   *      ...
   * end : <sigexp>
   * </p>
   *)
  (*%
   * @format({id}) "unbound" +d "functor:" +d id
   *)
  FunctorNotFound of {id:string}

  and 
  (**
   * <p>
   * structure foo =
   * struct
   *      ...
   * end
   * </p>
   *)
  (*%
   * @format({id}) "unbound" +d "structure:" +d id
   *)
  StructureNotFound of {id:string}

  and
  (**
   * <pre>
   *  type t = foo
   * </pre>
   *)
  (*%
   * @format({tyCon}) "unbound" +d "type" +d "constructor:" +d tyCon
   *)
  TyConNotFoundInRealisation of {tyCon : string}

  and
  (**
   * <pre>
   *  where type foo = ty (foo is a datatype)
   * </pre>
   *)
  (*%
   * @format({longTyCon})
   * "type" +d "annotation" +d "for" +d "datatype:" +d longTyCon
   *)
  DataConWithWhereType of {longTyCon : string}

  and
  (**
   * <pre>
   *  where type foo = ty (foo is a datatype)
   * </pre>
   *)
  (*%
   * @format({longTyCon})
   * "type" +d "annotation" +d "for" +d "datatype:" +d longTyCon +d " is not"
   * +d "well-formed"
   *)
  DatatypeNotWellFormed of {longTyCon : string}

  and
  (**
   * <pre>
   *  where type foo = real (foo is a eqtype)
   * </pre>
   *)
  (*%
   * @format({longTyCon})
   * "equality" +d "type" +d "required" +d "for:" +d longTyCon
   *)
  EqtypeRequiredInWhereType of {longTyCon : string}

  and
  (**
   * <pre>
   *  where type foo = real (foo is a eqtype)
   * </pre>
   *)
  (*%
   * @format({tyCon, wants, given})
   *   "arity mismatch in where type:" tyCon +d "given" +d given +d "arguments,"
   *  +d "wants" +d wants
   *)
  ArityMismatchInWhereType of {tyCon : string, wants : int, given : int}

  and
  (**
   * <pre>
   *  where type foo = ty (foo not defined)
   * </pre>
   *)
  (*%
   * @format({tyCon}) "type" +d "constructor" +d "not" +d "found:" + tyCon
   *)
  TyConNotFoundInWhereType of {tyCon : string}

  and 
  (**
   * <pre>
   *  type s 
   *  type t = int * int
   *  sharing type s = t
   * </pre>
   *)
  (*%
   * @format({tyConName})
   * "Type" +d  "sharing" +d "against" +d "concrete" +d "type:" + tyConName
   *)
  SharingOnTypeFun of {tyConName : string}

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({id}) "rigid" +d "type" +d "in" +d "type" +d "Realisation:" id
   *)
  RigidTypeInRealisation of {id : string}

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({id})
   * "NON-Flexible" +d "type" +d "in" +d "type" +d "Realisation:" id
   *)
  NONFlexibleTypeInRealisation of {id : string}

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({id})
   * "NON-Flexible" +d "type" +d "in" +d "type" +d "Realisation:" id
   *)
  RealisationDoesNotRespectEquality of {id : string}

  and 
  (**
   * <pre>
   * spec sharing lonstrid_1 = ... = longstrid_k
   * </pre>
   *)
  (*%
   * @format({id}) "rigid" + d "type" +d "in" +d "sharing" +d "structure:" id 
   *)
  RigidTypeInSharingStructure of {id : string}

  and
  (**
   * <pre>
   * spec sharing lonstrid_1 = ... = longstrid_k
   * </pre>
   *)
  (*%
   * @format({id}) "rigid" + d "type" +d "in" +d "sharing:" id 
   *)
  RigidTypeInSharing of {id : string}

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   *)
  FreeTypeVariablesAtTopLevel 

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   *)
  SignatureMatchFailed

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyCon})
   * "type" + d "constructor" +d "unbound" +d "in" +d "structure:" tyCon 
   *)
  TyStrMatchUnboundFailed of {tyCon:string}

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyCon})
   * "type" + d "constructor" +d "unbound" +d "in" +d "structure:" tyCon 
   *)
  TyStrEnrichNotFound of {tyCon:string}

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyCon})
   * "type" + d "in" +d "structure" +d "does not" +d "match" +d
   * "signature:" tyCon 
   *)
  TyStrEnrichFailed of {tyCon:string}

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({name1,ty1,name2,ty2})
   * "val" +d "type" +d "does not" +d "match" +d "signature:" 
   *    +1  "structure:" + name1 + ":" {ty1} 
   *    +1  "spec:"  name2 + ":" {ty2}
   *)
  VarIdEnrichFailed of
  {name1 : string, ty1 : Types.ty, name2 : string, ty2 : Types.ty }

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({name1,ty1,name2,ty2})
   * "constructor" +d "does not" +d "match" +d "signature:" 
   *    +1 "structure:" + name1 + ":" {ty1} 
   *    +1 "spec:"  name2 + ":" {ty2}
   *)
  ConIdEnrichFailed of
  {name1 : string, ty1 : Types.ty, name2 : string, ty2 : Types.ty }

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   *)
  TyConArgumentsArityMatchFailed of {tyCon:string}

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   *)
  StructureMatchFailed of {strid:string}

  and 
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({id}) "illegal" +d  "type" +d  "function:"   + id
   *)
  IllegalTypeFunction of {id : string}
  and

  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyConName}) "datatype " +d  "contains" +d  "unbound" + "type:"  + tyConName
   *)
  DatatypeContainUnboundType of {tyConName : string}

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyConName})
   * "Signature" +d  "mismatch" +d  "(arity):"   + tyConName
   *)
  ArityMismatchInSigMatch of {tyConName:string}

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyConName})
   * "Signature" +d  "mismatch" +d  "(equality):"   + tyConName
   *)
   EqErrorInSigMatch of {tyConName : string}

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyConName})
   * "Signature" +d  "mismatch" +d  "(tycon" +d "sharing):" + tyConName
   *)
   TyConMisMatchInSigMatch of {tyConName:string}
  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyConName1,tyConName2})
   * "Signature" +d  "mismatch" +d  "(tycon" +d "sharing):" + tyConName1 +d tyConName2
   *)
   SharingTypeMismatchInSigMatch of {tyConName1:string,tyConName2:string}
  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({Cons})
   * "Signature" +d  "mismatch" +d ":" "Constructors"  +d Cons +d "only" +d "occur" +d "in" +d "signature"
   *)
   RedunantConstructorInSignatureInSigMatch of {Cons : string}

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({Cons})
   * "Signature" +d  "mismatch" +d ":" "Constructors"  +d Cons +d "only" +d "occur" +d "in" +d "structure"
   *)
   RedunantConstructorInStructureInSigMatch of {Cons : string}

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({name})
   * "Signature" +d  "mismatch" +d  "(undefined):" + name
   *)
   IdNotFoundInSigMatch of {name: string}

  and

  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({name})
   * "Signature" +d  "mismatch" +d  "(undefined tycon):" + name
   *)
   unboundTyconInSigMatch of {name: string}

  and

  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({strName})
   * "Signature" +d  "mismatch" +d  "(undefined structure):" + strName
   *)
   unboundStructureInSigMatch of {strName: string}

  and

  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({varName})
   * "Signature" +d  "mismatch" +d  "(undefined val identifer):" + varName
   *)
   unboundVarInSigMatch of {varName: string }

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyConName,ty1,ty2})
   * "Signature" +d  "mismatch" +d  "(instance):" + tyConName + ":" +1 
   *    +1 "structure:" + {ty1}
   *    +1 "spec:"  + {ty2}
   *)
  InstanceCheckInSigMatch of {tyConName:string,ty1:Types.ty,ty2:Types.ty}

  and  
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyConName})
   * "Duplicate" +d  "type" +d "name" +d "in" +d "datatype:" + tyConName
   *)
  DuplicateTypeNameInDatatypes of {tyConName:string}
  
  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({tyConName})
   * "data" +d  "constructor" +d "required" +d "in" +d "signature:" + tyConName
   *)
  DataConRequiredInSigMatch of {tyConName:string}

  and
  (**
   * <pre>
   * </pre>
   *)
  (*%
   * @format({utvarName})
   * "User" +d  "type" +d "variable" +d "cannot" +d "be" +d
   * "generalized:" + utvarName
   *)
  UserTvarNotGeneralized of {utvarName:string}

  and
  (**
   * 
   *)
  (*%
   * @format
   * "function" +d "and" +d "library" +d "in" +d "FFI"+d "declaration" +d
   * "must" +d "be" +d "string."
   *)
  FFIFunctionLibraryName
  
  val isAnyError = ref false

  fun initializeTypeinfError () = 
      (UE.clearQueue errorQueue; isAnyError := false)
  fun getErrorsAndWarnings () = UE.getErrorsAndWarnings errorQueue
  fun getErrors () = UE.getErrors errorQueue
  fun isError () = !isAnyError
  fun getWarnings () = UE.getWarnings errorQueue
  fun enqueueError x = (isAnyError := true; UE.enqueueError errorQueue x)
  val enqueueWarning = UE.enqueueWarning errorQueue
  end

end
