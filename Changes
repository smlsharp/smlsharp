-----------------------------------------------------------------------------
SML# version 4.2.0 (released on 2025-03-24)

* Experimental aarch64 support has been added.
  SML# now works on Linux and macOS with ARM 64-bit processors.
  This is still experimental, and some features do not work similarly to
  amd64. For example, exporting an ML function to C sometimes causes an
  LLVM error, such as "LLVM ERROR: INIT_TRAMPOLINE operation is only
  supported on Linux".

* Uncurrying, tail call transformation, and code optimization has been
  improved by introducing new compilation phases. SML# compiler now
  generates much better code than the previous version.

* SML# compiler has been made faster by analyzing and optimizing its hot
  spots.

* Bugfix: Overloaded variable names were not allowed to occur in layered
  patterns.

* LLVM 20.1 support has been added.

-----------------------------------------------------------------------------
SML# version 4.1.0 (released on 2024-11-08)

* Changed and improved LLVM support.
  SML# now supports from LLVM 7.1 to LLVM 18.1.
  For the developers to precompile SML#, LLVM 7.1.0 is required.
  To precompile, set the "--with-llvm7" configure switch.

* Fixed a number of bugs including the issues #10, #39, #67, #68
  and added some test cases in ~/tests/data/regression.

-----------------------------------------------------------------------------
SML# version 4.0.0 (released on 2021-04-06)

* In agreement with Tohoku University, we (the SML# development team) have
  relicensed the SML# software.  It is now distributed under the MIT license
  copyrighted by the SML# development team.  See LICENSE file for the
  current license.

* We have relocated the SML# website at https://smlsharp.github.io/ and
  its distrution site at https://github.com/smlsharp/smlsharp .

* LLVM 11.1 support has been added.

-----------------------------------------------------------------------------
SML# version 3.7.1 (released on 2021-03-15)

* Fixed segmentation fault occurred when rank-1 polymorphic functions
  are exported and called from different modules.

* SML# now supports LLVM 12.

-----------------------------------------------------------------------------
SML# version 3.7.0 (released on 2021-01-04)

* Experimental feature: existential type variable declararion has been
  added in the _dynamiccase expression.  Now we can write

    fun apply x = _dynamiccase x of {'a} (f:'a -> int, x:'a) => f x;

  where {'a} is an existential type variable declaration local to the
  rule with the restriction that 'a must not escape from the scope.
  The type instance of 'a is dynamically computed every time the
  matching is performed.  The following expressions are correct and
  evaluate to 2.

    apply (Dynamic.dynamic (foldl (op +) 0, [1, 1]));
    apply (Dynamic.dynamic (trunc, 2.34));

* Bugs found in the concurrent and parallel garbage collector were fixed.
* Bugs found in the DynamicLink structure were fixed.
* Bugs found in the SQL integration were fixed.
* Bugs found in the value printer of the interactive mode were fixed.
* The SML/NJ Library has been updated to 110.99.
* Several modules in the SML/NJ Library has been ported to SML#.
* The JSON parser has been replaced with the one provided in the SML/NJ
  Library.  The YAJL library is no longer needed.
* SML# now supports LLVM 11.

SEQURITY ALERT: A potential code injection vulnerability was found in
the built-in JSON parser of SML# 3.6.0 and earlier.  This is due to
inappropriate interaction between FFI and GC.  Any SML# program that is
compiled by the SML# compiler version from 3.1.0 to 3.6.0 and using
SML#'s JSON feature (JSON.import, Dynamic.fromJSON, and/or
Dynamic.fromJSONFile) is affected.  It is recommended for SML# users
to upgrade your SML# installation and recompile programs that use the
JSON or Dynamic feature.

-----------------------------------------------------------------------------
SML# version 3.6.0 (released on 2020-05-29)

* SML#'s garbage collector is replaced with a novel concurrent and
  parallel one.  In the new garbage collection algorithm, no thread is
  dedicated for garbage collection.  Instead, each worker thread (Pthread)
  sometime acts as an collector running concurrently with other threads.
  This organization eliminates sequentialities due to memory management
  and achieves parallelism competitive with other parallel languages.
  Our benchmark programs (benchmark/benchmarks_parallel) shows good
  scalability: x50.7, x52.7, x44.6, and x37.0 speedup of the fib,
  mandelbrot, nqueens, and cilksort benchmark with 64 CPU cores of
  AMD EPYC 7501 2.0GHz.

* The SQL integration is refined so that SQL is integrated with SML#
  more seamlessly.  One of major changes is the new semantics of SQL
  value expressions.  Each subexpression that can be evaluated by SML#
  in an SQL query is evaluated by SML# and its value is automatically
  embedded in the SQL query.  SQL.Op.toSQL is no longer needed to embed
  a value.  For example, the function

    fn x => _sql db => select #e.salary from #db.employee where #e.age >= x

  now takes an integer (int), not an SQL expression fragment of type int
  ((int, 'w) exp).  Another change is the SQLite3 in-memory database
  support.  SQL.connectAndCreate allows us to use an in-memory database
  as a record storage.  For example:

    val d = _sqlserver SQL.sqlite3 ":memory:" : {foo:{a:int, b:string} list}
    val c = SQL.connectAndCreate d
    val l = List.tabulate (100000, fn x => {a = x, b = Int.toString x})
    val _ = (_sql db => insert into #db.foo (a, b) values l) c
    val r = (_sql db => select #foo.b from #db.foo limit 10) c
    val a = SQL.fetchAll r
    val _ = SQL.closeConn c

* SML# now supports LLVM 10.

* A lot of bugs has been fixed.

-----------------------------------------------------------------------------
SML# version 3.5.0 (released on 2019-12-24)

New features:
* Dynamic typing support.  You can make any statically-typed value to
  dynamically-typed value by Dynamic.dynamic primitive and perform
  dynamic type cast to get back the statically-typed value by _dynamic
  expression. For example:

    # val x = Dynamic.dynamic {a = 1, b = "c"};
    val x = _ : Dynamic.void Dynamic.dyn
    # val y = _dynamic x as {a:int, b:string};
    val y = {a = 1, b = "c"} : {a : int, b : string}

  JSON support is reorganized on top of the dynamic typing mechanism.
  The _json expression is integrated into the _dynamic expression.
  The following example shows the new notation of dealing with JSON data:
  
    # val x = Dynamic.fromJson "{\"a\":1, \"b\":\"c\"}";
    val x = _ : Dynamic.void Dynamic.dyn
    # val y = _dynamic x as {a:int} Dynamic.dyn
    val y = _ : {a : int} Dynamic.dyn
    # val z = Dynamic.view y;
    val z = {a = 1} : {a : int}
    # Dynamic.valueToJson z;
    val it = "{\"a\" : 1}" : string

* Polymorphic Type Elimination.  A new optimization phase named as
  PolyTyElimination is added.  This phase computes the set of possible
  type instances for each type abstraction and minimizes the insertion
  of extra lambda abstractions by the type-directed compilation.
  According to our evaluation using micro benchmarks, this achieves 10%
  speed-up and 12% code size reduction on average.

Improvements:
* The SML# compiler now uses LLVM 3.9.1 or later.  The latest one,
  LLVM 9.0.0, is preferable.

* Pthread support is turned on by default.  MassiveThreads and Pthread
  can be mixed in the same program.  --without-massivethreads is no
  longer needed to enable Pthread support.

* SIGINT is now handled in the interactive session.  By pressing Ctrl-C,
  you can abort the current execution and go back to the prompt.

* SQLite3 support is added.

* In addition to the above improvements, a lot of bugs has been fixed.

Other changes:
* SMLFormat now uses the same parser as the SML# compiler.

* Manpages of the smlsharp, smlformat, smllex, and smlyacc commands
  are provided.

-----------------------------------------------------------------------------
SML# version 3.4.0 (released on 2017-08-31)

New features:
* Automatic Makefile generation.  The smlsharp command with new "-Mm"
  command line option computes file dependency of the given programs
  and outputs a complete Makefile.

* Loading an additional library for the interactive mode.  New "-r"
  command line option let the compiler load a separately-compiled
  library into the initial interactive environment.

  By combining these two, you can use your own library in the
  interactive mode simply by the following three steps:
    $ smlsharp -Mm mylib.smi -o Makefile
    $ make mylib
    $ smlsharp -r mylib.smi

Improvements:
* The value and type printer of the interactive session is improved.

Other changes:
* The source tree has been reorganized.

-----------------------------------------------------------------------------
SML# version 3.3.0 (released on 2017-06-20)

* The new feature of this version is massive parallelism for
multicore processors, powered by MassiveThreads --- an efficient
light-weight thread library for multicore CPUs.  By the combination
of MassiveThreads and our fully concurrent GC, SML# is now capable
of running millions of threads on multicore processors, as seen in
thefollowing simple example:

  val cutOff = 10
  fun fib 0 = 0
    | fib 1 = 1
    | fib n =
      if n < cutOff
      then fib (n - 1) + fib (n - 2)
      else let val t = Myth.Thread.create (fn _ => fib (n - 2))
           in fib (n - 1) + Myth.Thread.join t
           end

The Myth structure is the binding library of MassiveThreads; it
provides primitives for thread creation and synchronization.

To enable the full functionality of MassiveThreads, set the
MYTH_NUM_WORKERS environment variable to 0 when you start an SML#
interactive session or run a SML# program.

* The SQL integration has been significantly improved.
Firstly, SQL query syntax becomes more direct and closer to the
SQL commands.  One can write

  val q = _sql db => select #t.name from #db.people as t
                     where (#t.age = 25 and #t.salary > 300)

instead of the old notation:

      val q = _sql db => select #t.name from #db.people as t
                         where SQL.andAlso (SQL.== (#t.age, 25),
                                            SQL.> (#t.salary, 300)).

Moreover, queries can be programmed by composing higher-order
functions for component clauses.  The above q is also coded as:

    val sel = _sql select #t.name
    val frm = fn db => _sql from #db.people as t
    val whr = fn () => _sql where (#t.age = 25 and #t.salary > 300)
    val q = _sql db => select...(sel) from...(frm db) where...(whr ())

Note that new SQL-related constructs are not compatible with old
one in the following points:

(1) SQL query syntax is changed as described above.

(2) SQL tables are now associated with ML lists and therefore you
    need to write "list" for each table type in _sqlserver
    declaration.  For example, write
      val s = _sqlserver : {people : {name:string, age:int, salary:int} list}
    instead of
      val s = _sqlserver : {people : {name:string, age:int, salary:int}}.

(3) The _sqleval and _sqlexec construct are no longer needed and
    avaiable.  The new _sql expression is a function that executes
    a query through the given database connection.  For example, to
    execute the above query, one can just call it with a connection
    as follows:
      val c = SQL.connect s
      val result = q c

* Another relatively minor new feature is type reification mechanism.
Using this, for example, SML# define a polymorphic print function "pp"
at the top-level.  One can do as follows:
 # pp;
 val it = fn : ['a#reify. 'a -> unit]
 # pp 1;
 1
 val it = () : unit
 # pp [1,2,3];
 [1, 2, 3]
 val it = () : unit
 # pp 3.14;
 3.14
Note that pp is not a macro but an ordinary polymorphic function.
Document on this is not yet ready, but the interested programmer may
look at some modules in src/compiler/compiler-utils/reflection/main.

* In addition to the above improvements, a lot of bugs has been fixed.

-----------------------------------------------------------------------------
SML# version 3.2.0 (released on 2016-09-16)

This version contains the type system for natural join operations.
With this, SQL integration is extended to natural join operator, as
seen in the following example:

# _sql db => 
  select #t.name, #t.sarary 
  from (#db.Employees natural join #db.Salary) as t;
val it = fn
  : ['a#{Employees: 'b, Salary: 'c},
     'b#{},
     'c#{},
     'd::{int, intInf, word, char,...},
     'e::{int, intInf, word, char,...},
     'f::{int, intInf, word, char,...},
     'g::{int, intInf, word, char,...},
     'h#{name: 'd, sarary: 'f}.
       ('h = 'b join 'c) =>
       'a SQL.db -> ('d * 'f) SQL.query]

Other improvements:
* Typeful JSON support is extended to null values.  JSON's "null"
  value can be coerced to "NONE" of an "option" type in SML#, as
  seen in the following example:

  # val j = JSON.import "{\"foo\":null, \"hoge\":1}";
  val j = _ : JSON.void JSON.dyn
  # _json j as {foo: string option, hoge: int option};
  val it = {foo = NONE, hoge = SOME 1}
           : {foo: string option, hoge: int option}

* Minor improvements on PostgreSQL's type support.
* Minor refinements on value printers in interactive session.

Fixed bugs:
* Fixed a memory allocation bug caused by a combination of a
  record update expression and a statically-allocated record.

-----------------------------------------------------------------------------
SML# version 3.1.1 (released on 2016-07-15)

Fixed bugs:
* Fixed bugs of _jsoncase expression, which did not work unfortunately.
* Stopped printing the values of opaque types in interactive mode.
* Type arity check was not performed in foreign function types.
* Fixed bugs of excpetion handling.
* Fixed errors in the configure script.

Improvements:
* Improvements in SQL integration:
  * added INNER JOIN support.
  * refined the compilation of SQL queries.
  * slightly changed the type of SQL queries.
* Refined type printer in interactive mode.

-----------------------------------------------------------------------------
SML# version 3.1.0 (released on 2016-05-26)

This version contains the full implementation of JSON support
described in the forthcoming paper: 
  A Calculus with Partially Dynamic Records for Typeful Manipulation of
  JSON Objects" Atsushi Ohori, Katsuhiro Ueno, Tomohiro Sasaki, Daisuke
  Kikuchi, 
to appear in ECOOP 2016 Research Track.
http://2016.ecoop.org/event/ecoop-2016-papers-a-calculus-with-partially-dynamic-records-for-typeful-manipulation-of-json-objects

A pre-version is available on the SML# home page.

-----------------------------------------------------------------------------
SML# version 3.0.1 (released on 2016-04-04)

Fixed bugs:
* Fixed segmentation faults, mysterious type errors, and improper value
  printing occurred in the interactive mode.

-----------------------------------------------------------------------------
SML# version 3.0.0 (released on 2016-03-31)

This is a major release of the SML# language system with a number of
improvements and bugfixes.  The notable changes include the following:

* x86_64 support: The SML# compiler now works on 64-bit platform and
generates 64-bit native code.

* Native multithread support: The multithread support is enabled by
default.  The user can import POSIX thread APIs through SML#'s foreign
function interface and enjoy multithread programming in SML#.  For
example, the "spawn" primitive can be implemented by the following
user-level code:

  type pthread_t = unit ptr  (* system dependent *)
  val pthread_create =
      _import "pthread_create"
      : (pthread_t ref, unit ptr, unit ptr -> unit ptr, unit ptr)
        -> int
  fun spawn f =
      let
        val ret = ref (Pointer.NULL ())
      in
        pthread_create (ret, Pointer.NULL (), f, Pointer.NULL ());
        !ret
      end

* Fully concurrent garbage collection: An unobtrusive concurrent
non-moving garbage collector has been integrated.  This collector runs
in a separate thread and never stop any thread due to garbage
collection.  This colletor improves both response time and throughput
of SML# programs in most cases.

For the details, see the SML# 3.0.0 documentations.
 * The Japanese version:
   http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/3.0/ja/index.xhtml
 * The English version:
   http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/3.0/en/index.xhtml
The documents contain an overview of the SML# language and a
comprehensive tutorial, which provides sufficient information to start
writing SML# programs.

Enjoy!

-----------------------------------------------------------------------------
SML# version 2.0.0 (released on 2014-04-04)

This is the brand new release of the SML# language system.  The most
notable change is that the SML# compiler now works with the LLVM
Compiler Infrastructure.  The new SML# compiler generates LLVM IR code
and produces native code through LLVM.  More than half of compilation
phases and library modules has been rewritten for the LLVM support.
These changes also greatly speed up the compilation processes.

The following compile options are added:
 * Optimization options such as -O1, -O2, -O3, -Os and -Oz.  These
   options enables LLVM's code-level optimization.
 * -emit-llvm.  If this option is specified, SML# compiler produces
   LLVM IR code or LLVM bitcode instead of native code.

While LLVM supports multiple target platforms, this version of SML#
supports only x86 target.  At least x86-64 support will be available
in near future.

For the details, see the SML# 2.0.0 documentations.
 * The Japanese version:
   http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/ja/index.xhtml
 * The English version:
   http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/2.0/en/index.xhtml

Enjoy!

-----------------------------------------------------------------------------
SML# version 1.2.0 (released on 2012-11-14)

Improvements:
* Functor applications and structure replications in interface files
  are supported.
* Tuned up the non-moving garbage collector.
* SML# compiler code is optimized, achieving fast compilation.
* Refined type and value printers and error messages.
* Inlining optimization is implemented.
* Modified ml-yacc command and libraries to be suitable for SML#.
* Implemented some optimizations to smlformat.
* Added interface files for benchmarks.

Fixed bugs:
* Fixed several bugs related to functor.
* Fixed a bug of polymorphic record pattern.

-----------------------------------------------------------------------------
SML# version 1.1.0 (released on 2012-08-08)

Improvements:
* Functor definition is now available in interactive mode.
* SML# compiler now rejects signatures that do not have any instance.
  Rejecting them is not strictly compliant with the definiton of SML,
  but necessary for separately compiling a functor.
* Refined value, type and signature printers of interactive mode.
* Refined type error messages.

Fixed bugs:
* Fixed several bugs of functor with signature constraints.
* Fixed a bug of eqtype constraint.
* Fixed a bug of opaque signature constraint with datatype.
* Fixed a bug of exception replication.
* Fixed a bug that handle expresions may cause infinite loop.

-----------------------------------------------------------------------------
SML# version 1.0.3 (released on 2012-06-25)

Fixed bugs:
* Fixed a bug of type inference phase.
* Fixed a bug that some form of polymorphic record selector caused a
  runtime error.
* Fixed a bug that accepted duplicate labels in a record expression
  in some cases.
* Fixed a bug of evaluation of comparison operators with two constant
  literals.
* Fixed a bug of elaboration of "withtype" of "abstype" declaration.

-----------------------------------------------------------------------------
SML# version 1.0.2 (released on 2012-05-14)

Fixed bugs:
* Some illegal SQL select queries were accepted due to lack of a type
  unification.
* Using capital letters in an SQL query caused runtime error when the
  query is sent to a database server.
* Real.fmt returned wrong results. This bug was also affected to the
  value printer of the interactive mode.
* Name evaluation passed duplicate link symbols in a case that those
  symbols are declared in different interface files.
* "make" was aborted due to no rule on .desc files if --enable-fast-build
  is enabled.

-----------------------------------------------------------------------------
SML# version 1.0.1 (released on 2012-04-24)

Fixed bugs:
* Vector.update caused segentation fault.
* Bound type variables in a record kind caused a BUG exception.
* opeining a structure containing overloaded ids caused a BUG exception.

Improvements:
* builtin-primitives are now printed in the interactive session.
* link time warning about tmpnam(3) is suppressed.
* --enable-fast-build option is added to configure script.
  This option reduces the time for building SML# compiler by
  reusing assembly code of minismlsharp.

-----------------------------------------------------------------------------
SML# version 1.0.0 (released on 2012-04-06)

SML# 1.0.0 is the first fully functional version of the SML# language
system. It supports all the features the SML# project had initially
aimed at, including:

 *  Record polymorphism.
 *  Direct interoperability with the C langauge.
 *  Seamless integration of SQL.
 *  True separate compilation and linking

In addition to these goals we had set, we have also completed the
development of:

 *  Native multithread support on multicore hardware.
 *  A fully concurrent non-moving GC.

These two feature have not yet been well tested, and are not supported
in this version. (Multithread support is turned off by default and the
concurrent GC is not included.) These two features will soon be
available in a forthcoming SML# version. 

For the details, see the SML# 1.0.0 documentations.
 * The Japanese version:
   http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/1.0/ja/index.xhtml
 * The English version:
   http://www.pllab.riec.tohoku.ac.jp/smlsharp/docs/1.0/en/index.xhtml
The documents contain an overview of the SML# language, and a
comprehensive tutorial, which provides sufficient information to start
writing SML# programs.

Enjoy cool and practical programming with SML# 1.0.0

-----------------------------------------------------------------------------
SML# version 0.90 (released on 2011-09-14)

1. Overview

SML# 0.90 is an experimental release of the forthcoming new generation
of SML#.

This 0.90 version is a separate compilation system for SML# (which is
backward compatible with the Standard ML). This version complements
the interactive compiler of 0.60 series.

The functionality of separate compilation is outlined in the following
section. A detailed document will be released in the forthcoming SML#
1.00, which combines this separate compilation system and the
interactive compiler. Meanwhile, the interested programmers and
researchers can contact us for more details. 


2. Separate Compilation Overview

2.1 smlsharp command

Typical functionalities of the SML# 0.90 compiler command include the
following.

(1) Compile one source file into an object file. The command line

  % smlsharp -c foo.sml

reads foo.sml and produces foo.o, consulting with its interface
file. The programmer can specify an interface file of foo.sml in one
of the following two ways:
* to include a compiler directive line:
  _interface "<filename>"
* to create a file foo.smi in the same directory.

(2) Link object files. The command line

 % smlsharp A.smi

locates all the object files referenced in A.smi, links them together
(by invoking the system linker, ld) and produces an executable file,
whose default file name is a.out. 

(3) Compile and link a source file. The command line

 % smlsharp A.sml

compiles A.sml, links it with all the files referenced in A.smi
and generates a.out.

In (2), (3), if the source file references external C functions
through _import declarations, then the programmer should 
list their object files (generated by C complier) as in

 % smlsharp A.sml clib.a cfun.o

In addition, smlsharp command performs a number of other things
related to compiling and linking.

2.2 Interface language

To separately compile a source file, foo.sml, the programmer need to
write its interface file, whose default name is foo.smi. This
interface file specifies the resources foo.sml requires and those that
are provided by foo.sml.

The syntax of an interface file consists of the following.
i. a list of require specification of the following form
  _require <interface file name>

ii. a list of provide specifications.
Its syntax is defined roughly as follows.

   <itopdec> ::= <idecl> | <ifundecl>
   <idecl> ::= val <valdesc>
            |  type <itypbind>
            |  eqtype <tyvarSeq> id (= <ty>)
            |  datatype <idatbind>
            |  datatype <id> = datatype <longid>
            |  exception <exbind>
            |  structure <id> = <istrexp>
            |  infix <n> <id>
            |  infixr <n> <id>
            |  noninfix <n> <id>
<itypbind> ::= <tyvarSeq> <id> = <ty>
            |  <tyvarSeq> <id> ( = <ty> )
<idatbind> ::= <tyvarSeq> <id> = <conbinds> [and <idatbind>]
            |  <tyvarSeq> <id> ( = <conbinds> [and <idatbind>] )
<istrexp>  ::= struct <idecl-seq> end
<ifundec>  ::= functor <id> ( <id> : <sigexp> )  = <istrexp>

Nonterminals not defined are analogous to those of Standard ML
signature.

They resemble Standard ML signatures but they also need to 
specify the information needed for smlsharp to compile a 
source that reference this interface into object code.
Extra syntax are there for this purpose.


-----------------------------------------------------------------------------
SML# version 0.62 (released on 2010-12-17)

1. Overview

This is a patch release of SML# 0.60 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- added static allocation optimization.
  This optimization allocates constant records and closures to memory
  at compile time. This optimization is available only for native code
  and enabled by default. To disable this optimization, specify
  --xdoStaticAllocation=no option to the command line.
- restructured the prelude library to improve performance.
  It also reduces time for compiling the native prelude library.
- rewrote register allocation phase.
  New register allocation phase is based on Appel-George's iterative
  register allocator with register coalescing. The register coalescing
  is enabled by default. To disable the coalescing, specify
  --xdoRegisterCoalescing=no option to the command line.
- enabled generational version of the non-moving bitmap marking
  garbage collector by default.
  This collector is available only for native code.
- added support for SQL commands for transaction control.
  You may write "begin", "commit" or "rollback" command in a _sql
  expression as a SQL command.
- added SQL.queryString and SQL.commandString primitive function.
- fixed bug of handling real variables defined at toplevel in native
  code generation.
- fixed type errors of intermediate representations for native code
  generation.
- refactored native code backend.

-----------------------------------------------------------------------------
SML# version 0.61 (released on 2010-11-26)

1. Overview

This is a patch release of SML# 0.60 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- added a feature that CConfig creates a cache file for check results.
- added Pointer structure.
  This structure is experimental and provides primitive functions for
  C pointers such as pointer arithmetics and memory access.

-----------------------------------------------------------------------------
SML# version 0.60 (released on 2010-11-12)

1. Overview

An experimental release of a new feature of SML#. 
Only the source package is provided. 

2. The new feature

The major new feature of SML# 0.60 is seamless interoperability with
database systems. 

In this version, (a subset of) SQL is directly available as
first-class SML# expressions and can be freely combined with any other
language constructs in SML#. The SML# type system with record
polymorphism always infers a principal type for any type consistent
expression involving SQL query expressions. The compiler separates SQL
queries and delegates them to a database server. 

To show a simple example, consider the following an SQL query
    SELECT name, age
    FROM person 
    WHERE age <= 25
This is a function which takes a connection to a database that contains
"person" table having "age" column of type integer and name column of
any SQL supported atomic values possibly containing null. The
following shows an SML# session defining this query:
 # val young =
       _sql db =>
            select #person.name as name, #person.age as age
            from #db.people as person
            where SQL.<= (#person.age, 35);
 val young = fn
   : ['a#{people:'b},
      'b#{age:int, name:'d},
      'c,
      'd::{int, word, char, string, real, 'e option},
      'e::{int, word, char, bool, string, real}.
      ('a, 'c) SQL.db -> {age: int, name: 'd} SQL.query]
"'e option" represents values possibly containing null. The inferred
type is indeed a principal type of "young". In addition to SQL
queries, database servers and database connections are also typed
first-class citizens. These feature allow the SML programmer to write
a typed polymorphic higher-order programs with SQL queries. 

In this version, only PostgreSQL is supported; MySQL binding will be
added in a future release.

For a brief description on how to use this feature, see the web page: 
http://www.pllab.riec.tohoku.ac.jp/smlsharp/?FeatureDatabaseIntegration

3. Oteher changes and improvements

none.

-----------------------------------------------------------------------------
SML# version 0.58 (released on 2010-10-16)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- fixed a bug that String.sub returns a negative integer if given
  string contains a non-ASCII character.
- fixed a bug of printing string values on interactive mode.
- fixed a bug of compilation of polymorphic flexible record patterns.
- refined messages of type errors due to record kinds.

-----------------------------------------------------------------------------
SML# version 0.57 (released on 2010-10-01)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- Updated parser and improved conformance with the Definition.
 - accept unmatched "*)".
 - reject "*" as a tycon.
 - reject integer starting with "0" as a record label.
- Updated the build system so that SML# can be built only by MLton.
 If --with-mlton option is specified to configure, and the build
 system uses MLton (without SML/NJ) to compile SML# compiler and
 other tools.

-----------------------------------------------------------------------------
SML# version 0.56 (released on 2010-09-17)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- refined several Makefiles and .cm files.

[SMLDoc]
- fixed errors in Makefile.

[mlb2use]
- added support for SML/NJ .cm files.

-----------------------------------------------------------------------------
SML# version 0.55 (released on 2010-09-03)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- fixed a bug of parsing unclosed comments and unclosed string
 literals. They now causes a parse error.

-----------------------------------------------------------------------------
SML# version 0.54 (released on 2010-08-20)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. the Basis test suite

This version includes the first public version of our test suites for
Basis Library.

One of advantages of Standard ML is that implementations share the
specification of the language and Basis library.  It encourages
portability and stable long life of softwares written in Standard ML.

We present a test suite for Standard ML Basis library.  Compiler
implementors can use it to check the conformance of their implementation
to the Basis specification.  We hope that this test suite helps to
eliminate differences remaining among implementations of Basis library.

This test suite is at smlsharp/SMLUnit/basis/ in the SML# source package.

3. Other changes and improvements

[SML#]
- rewrote Array2 from scratch to fix problems.
- added Word8Array2.
- added CharArray2.
- implemented overflow check in Int.{scan, fromLarge, div, mod, quot, rem}.
- implemented overflow check in IntInf.toInt.
- fixed bugs of IntInf.log2.
- fixed a bug of Real.split on cygwin.
- added error checks to Date functions.

-----------------------------------------------------------------------------
SML# version 0.53 (released on 2010-08-06)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
- fixed a bug of raising Div exception.
- fixed a bug of floating-point literal compilation in native backend.
- fixed a problem of SIGINT handling.
- fixed many bugs in Array, Char, CharVector, Real, IEEEReal, String,
 VectorSlice, and Word, Word8 structures.
- implemented String.scan, String.concatWith, and Real.nextAfter.
- improved conformance of IEEEReal structure with the Basis library
 specification.

[SMLUnit]
* added assert functions for tuples and datatypes defined in Basis
  structures.
* changed the type of assert functions to return a unit.

-----------------------------------------------------------------------------
SML# version 0.52 (released on 2010-07-23)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
* fixed a bug of an alternative implementation of signbit in the native
  runtime. This fix affects several primitive functions defined in Real
  structure.
* fixed a bug of functor management and global symbol resolution in
  native code backend.

-----------------------------------------------------------------------------
SML# version 0.51 (released on 2010-07-09)

1. Overview

This is a patch release of SML# 0.50 series.
This version is still experimental.

2. Changes and improvements

[SML#]
* slightly improved compilation for "orelse" and "andalso".
* slightly speed up of booting interactive mode by compacting pickled
  context of the prelude.
* refined unification algorithm to print more reasonable error messages.

[SMLUnit]
* added support files for MLton.

[mlb2use]
* fixed a bug of dealing with backslashes.

-----------------------------------------------------------------------------
SML# version 0.50 (released on 2010-06-25)

1. Overview

An experimental release of a new feature of SML#. 
Only the source package is provided. 

2. The new feature

The major new feature of SML# 0.50 is first-class overloading.

First-class overloading may not be ardent wanted by ordinary SML
programmers, but we find this feature essential in our development of
seamless interoperability with database system, which we shall include
in our near future release.

This version implements a lightweight first-class overloading mechanism
that is readily realized by SML#'s polymorphic record compilation.

With this extension, overloaded operators such as + and > are now
first-class values having a polymorphic type that represents their
overloaded status, as seen in the following example:
 # op +;
 val it = fn
     : ['a::{int, IntInf.int, real, Real32.real, word, Word8.word}.
        'a * 'a -> 'a
 # fun sumList nil z = z
 >   | sumList (h::t) z = sumList t (h+z);
 val sumList = fn
     : ['a::{int, IntInf.int, real, Real32.real, word, Word8.word}.
        'a list -> 'a -> 'a]
 # sumList [1,2,3] 0;
 val it = 6 : int
 # sumList [1.1,2.2,3.3] 0.0;
 val it = 6.6 : real
where "::{....}" in 'a::{....} is an overload kind, restricting
possible instances of type variable 'a.

Any operator having the following two properties can be supported.
1. Its overloaded nature is representable as a polymorphic type using
   overload kinds. Its type can contain multiple overloaded type
   variables. The instance types in their overload kinds may also
   contain type variables possibly with overload kind restriction.
2. Each instance corresponds to a set of type instances specified by
   ground type constructors and wild card "_".
For example, the type
  ['a#{int, real, 'b list, 'c array}, 'b#{bool, char}, 'c#{int, bool}.
   'a * 'a -> 'a]
represents an overloaded binary operator having the instances for
{int, real, bool list, char list, int array, bool array}. These
correspond to the following instantiations of 'a, 'b, and 'c:
  [int,_,_] for int op
  [real,_,_] for real op
  [bool list, bool, _] for bool list op
  [char list, char, _] for bool list op
  [int array, _, int] for int array op
  [bool array, _, bool] for bool array op

In the currently version, overloaded operator declaration is not yet
made available to the programmer. We plan to include a special
syntax for this purpose in future version.

3. Oteher changes and improvements

[SML#]
* fixed a bug of pretty-printing for evaluation results in interactive mode.
* fixed a bug of equality type inference.
* fixed a bug of introducing dummy types due to value restrictions.
* made type printers much prettier.

[SMLFormat]
* fixed a bug in handling newline indicators in nested guards.
* updated documents.

[OLE/SML#]
* a minor-change of OLE_DECIMAL signature.
* updated a sample code using MS Excel.

-----------------------------------------------------------------------------
SML# version 0.43 (released on 2010-06-11)

1. Overview

This is an release of SML# 0.42. This version is still experimental
and not intended to replace SML# 0.31.

2. Changes and improvements

[SML#]
* added native code generation for Windows. Both mingw and cygwin
  are supported.
* improved native callback function generation so that C program
  can call ML functions anytime.
* added interoperability for float (32bit floating point number)
  to the native code generation.
* fixed a bug of native code selection.
* improved accuracy of native code compilation for floating point
  constant literals.
* implemented Real32 structure.
* fixed a bug of Array.array.
* fixed a bug of printing an exception.
* refined UnmanagedString.export.
* fixed a bug of native version of UnmanagedMemory.export.
* fixed a bug of smlsharp2exe.
* fixed a buffer overflow in the runtime.

[OLE/SML#, .NET/SML#]
* changed module configuration of OLE library.
* supported OLE SAFEARRAY of builtin types of .NET, except for char.
* fixed a minor problem in handling a literal in C# code.

-----------------------------------------------------------------------------
SML# version 0.42 (released on 2010-05-28)

1. Overview

This is an bug-fix release of SML# 0.41. This version is still
experimental and not intended to replace SML# 0.31.

2. Changes and improvements

* fixed a bug of hiding int values in result printings after open Int.
* fixed a bug of user type variable unification.
* fixed a bug of Word32.fromLargeWord.
* fixed a bug of compiling negative IntInf constant literals.
* fixed a bug of equality of exceptions.
* suppressed diagnosis messages printed by native code backend.
* improved result printing for hidden types.
* implemented a few functions in Real32.real.
* SMLUnit: added Assert.assertEqualByCompare.
* Java/SML#: fixed conflictions between Java identifiers and SML keywords.
* .NET/SML#: added support for all built-in datatypes of C#.
* OLE/SML#: added support for I2, UI2, I8, UI8, R4 and DECIMAL.
* OLE/SML#: fixed problems in passing I4 and I1.

-----------------------------------------------------------------------------
SML# version 0.41 (released on 2010-05-14)

1. Overview

This is a bug-fix release of SML# 0.40. This version is still
experimental and not intended to replace SML# 0.31.

2. Changes and improvements

* fixed problems of building SML# on Windows.
* smlformat command now raises an error if no file is specified.
* fixed a bug of isAlphaNum of LMLML.
* fixed a bug of Word32.toLargeIntX.
* fixed a bug of String.fromString and String.fromCString.
* changed LMLML interface.
* added and updated sample code for Java/SML#.

-----------------------------------------------------------------------------
SML# Version 0.40 (released on 2010-04-30)

1. Overview

This is an experimental release for testing new backend and runtime
system. It is not intended to replace SML# 0.30.

2. New features and improvements of SML#

* Native code generation for x86 Linux and Intel-based Mac OS X.

  The native code compiler backend produces native object files that
  can be linked with C libraries by standard linker (e.g. ld
  command) without any unusual extension and hand-written glue code.

  To try the native code generation, invoke SML# comiler with
  --native option. The compiler produces an executable file named
  "a.sme". See SML# website for details.

* Runtime library for native code.

  This library also includes non-moving bitmap marking garbage
  collector.

* Experimental module flattening and ID allocation phases.

3. Other improvements

* Java/SML# interface:
  * fixed a bug in renaming overloaded Java methods and constructors
  * supported java array of float and long.
  * improved Java exception handling.
  * minor-changed Java library interface.

-----------------------------------------------------------------------------
SML# Version 0.30 (released on 2007-07-02)

1. Overview

The major change from SML# 0.20 is implementation of several
optimization phases in the SML# compiler, among which the most
significant is Record Unboxig described below.


2. Distribution Package

The SML# distribution package is re-organized to contain the SML#
compiler and its supporting tools in one package. The distribution
package is available in the following forms.
(a) Source tar file.
  smlsharp-0.30.tar.gz
(b) Mac OS X universal binary (after 10.4)
  smlsharp-0.30-Universal-Installer.dmg
(c) Windows binary installer
   smlsharp-0.30-mingw.exe
Each of the above package contains the following:
* the SML# compiler and its supporting library including LMLML
* SMLFormat (a pretty printer generator)
* SMLDoc (a document generation tool)
* SMLUnit (a unit test support tool)

3. Contact information and mailing list
- The contact address of the SML# development team.
  smlsharp @ pllab . riec . tohoku . ac . jp 
- The SML# mailing list:
  smlsharp-list @ pllab . riec . tohoku . ac . jp  
  This list is for general discussions on the SML# language, the
  compiler and its supporting tools. This is open to everyone.
  For more details, visit the "Contact Us" page of the SML# web.


4. New Features of the SML# compiler
4.1 Printer Control
The following structure is added to control the printer used to print
binding information in the interactive session

SMLSharp.Control.Printer 
: sig
    val getColumns : unit  -> int
    val getMaxDepth : unit  -> int option
    val getMaxRefDepth : unit  -> int
    val getMaxWidth : unit  -> int option
    val setColumns : int  -> unit
    val setMaxDepth : int option  -> unit
    val setMaxRefDepth : int  -> unit
    val setMaxWidth : int option  -> unit
  end

4.2 Optimization
The following optimization phases have been implemented.

(a) Record Unboxing
This optimization attempts to "unbox" tuples/records by flattening
component tuples and changing top-level tuples to multiple value
passing. It is a type-directed source-to-source transformation that
does not seem to be considered in existing literature or compiler.
The required type based analysis is quite simple but shown to be very
effective. Experiments on this technique shown a 27% speed-up in the
lexgen benchmark and a 21% speed-up in mlyacc benchmark. The compiler
switch 
 --xdoRecordUnboxing=yes/no 
enables/disables this optimization. It is enabled by default. 

(b) Record Alignment
To meat architecture requirements, the SML# compiler aligns record
component such as (unboxed) floating point values to double-word
boundary by inserting padding words. This would introduce some runtime
overhead, especially in the presence of polymorphism. The Record
Alignment optimization attempts to minimize this overhead cost as much
as possible. The compiler switch 
  --xalignRecord=yes/no
enables/disables this optimization. It is enabled by default. 

(c) Representation Analysis
This optimization attempts to reduce the overhead due to type-directed
compilation for those polymorphic functions that are instantiated to
types representing the same runtime property by statically computing
the type attributes. The compiler switch 
 --xdoRepresentationAnalysis=yes/no
enables/disables this optimization. It is enabled by default. 

(d) Other Conventional Optimizations.
In addition to those new type-based optimization, the version 0.30
also implements the following conventional optimizations.
 Optimization                   Compiler Switch 
 constant folding               --xdoConstantFolding=yes/no
 common expression elimination  --xdoCommonExpressionElimination=yes/no
 useless code elimination       --xdoUselessCodeElimination=yes/no
 stack slot minimization        --xdoStackReallocation=yes/no

4.3 Other Changes
(a) SML# executable file name
In the batch-mode, the current SML# executable file name can be
obtained by the function:
  SMLSharp.CommandLine.executableImageName : unit -> string option
In the interactive mode, it returns NONE.

(b) "Shebang" line in a source file.
 By default, the SML# compiler ignores the first if it begins "#!"
 (shebang line). This feature is used to execute SML# file in a Unix 
 shell as shown in the following example.
   $ cat foo.sml
   #!/usr/local/bin/smlsharp
   print "foo\n";
   $ ./foo.sml
   foo
The compiler switch 
  --xskipShebang=yes/no
enables/disables this feature. It is enabled by default.

4.4 bug fixes
Several minor bugs are fixed:
* Make & install fails on Free BSD
* Make fails for SMLUnit, SMLDoc, and SMLFormat on Unix/Linux due to
  improper newline codes in their source files.
* Tests and benchmarks fail in the system made with SML/NJ 110.63
* "smlsharp -c" command does not report error messages properly.
* Functions fromLarge, toLarge, toLargeX were missing in Word[N] structures.
* TextIO.flushOut sometimes fails to flush the output buffer
* Signature mismatch error due to difference of constructor order in
  datatype def and spec.
* Missing error check for a layered pattern with a long id as its left pattern


5. Tools
5.1 SMLFormat
Three constructors, MaxDepthOfGuards, MaxWidthOfGuards and CutOverTail,
have been added to SMLFormat.parameter datatype. These can be used to
limit the size of the formatted string.

5.2 SMLUnit
The following two assert functions have been added to SMLUnit.Assert
structure. 
 val assert : string -> bool -> unit
 val assertSameArray : 'a array assertEqual

-----------------------------------------------------------------------------
SML# Version 0.20 (released  on 2007-03-30)
